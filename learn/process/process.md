- [进程](#%E8%BF%9B%E7%A8%8B)
    - [最简单的进程](#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%9B%E7%A8%8B)
        - [需要保护的内容](#%E9%9C%80%E8%A6%81%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%86%85%E5%AE%B9)
        - [如何保存进程](#%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%BF%9B%E7%A8%8B)
        - [进程控制块 PCB](#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-pcb)
        - [特权级变换： ring 1-> ring 0](#%E7%89%B9%E6%9D%83%E7%BA%A7%E5%8F%98%E6%8D%A2%EF%BC%9A-ring-1--ring-0)
        - [特权级变换， ring 0 -> ring 1](#%E7%89%B9%E6%9D%83%E7%BA%A7%E5%8F%98%E6%8D%A2%EF%BC%8C-ring-0---ring-1)
    - [时钟中断处理程序](#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F)
        - [总结](#%E6%80%BB%E7%BB%93)
        - [中断重入](#%E4%B8%AD%E6%96%AD%E9%87%8D%E5%85%A5)
    - [系统调用](#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8)
    - [8253/8254 PIT](#82538254-pit)
# 进程

  为了简单的原则，我门让所有的任务运行在ring1， 而让进程切换运行在ring0.

诱发进城费切换的原因不止一种，比较典型的是发生了时间中断，中断处理程序会将控制权交给进程调度模块，如果系统认为应该仅此进行进程切换，当前进程的状态会被保存起来，队列中的下一个进程将被恢复执行。
## 最简单的进程
一个进程在执行的过程中，这是时钟中断发生了，特权级别从ring1跳到了ring0， 开始执行时钟特权中断处理程序，中断处理程序这时调用进程调度模块，制下一个应该运行的进程，当中段处理程序技术的时候，下一个进程准备就绪并开始执行，特权级别从ring0 跳回到ring 1。

所以如果我们想要实现进程和进程的调度，需要完成以下几项。

* 时间中断处理程序
* 进程调度模块
* 两个进程

### 需要保护的内容
进程被切换的时候，只有被保护的内容才有被保存的需要，我们进程需要运行，无非是需要寄存器和内存，在这里不考虑内存的重叠问题，那我们只需要保存寄存器的值。


### 如何保存进程
我们可以通过push 和 pushad两条指令来保存寄存器的值。我们可以把它写在时钟中断的最顶端，以便中断来了之后可以马上被执行。

那么当我们需要恢复进程的执行的时候，只需要简单的通过pop寄存器就可以弯沉，在时钟中断的最后执行指令iretd，就可以恢复进程的执行。

### 进程控制块 PCB
我们将进程的状态保存在PCB中，多个PCB组成一个进程数组，当寄存器的值已经被保存到了进程表中术后，那么我们就会面临了不同的栈，进程栈和内核栈。

### 特权级变换： ring 1-> ring 0
对于有特权级别的转移的，如果是外层到内层转移，需要从tss中去除内层的ss 和 esp 作为目标大司马的 ss 和ESP。所以我们
需要事先准备好tss。由于每个进程相对队里，我们需要把设计到的描述符放在局部描述符表LDT中，所以我们还要为每个进程准备LDT。

### 特权级变换， ring 0 -> ring 1
我们发生了一次发生了时钟中断来启动进程A，利用iretd来实现ring0 到 ring1 转换。

## 时钟中断处理程序
最简单的时钟中断子程序直接什么都不做，直接从中断中返回就可以完成了。

既然在程序开始的时候需要用到进程表中各项的值，我们首先要对值进行初始化。一个进程开始之前，只要指定好各段寄存器的值，eip,esp,eflags就可以正常运行。所以我们必须设置的初始化的寄存器列表为：cs, ds, es, fs, gs, ss, esp, eip, eflags。

但是这里的cs, ds寄存器对应的是LDT而不是GDT中的描述符，所以我们的另一个任务是初始化LDT，可以把它放在进程表中，从逻辑上看，由于LDT是进程的一部分。同时，我们必须在GDT中添加相对应的描述符，并在合适的时间将相应的选择子加载给ldtr.

其次我们还必须初始化一个TSS，并在GDT中添加一个描述符，对应的选择子被加载给TR这个寄存器。在TSS中我们用到的只有ring0 的ss 和 esp。

进程表，进程体， GDT 和 TSS 他们之间大概可以一下三个部分：


### 总结

在这个进程的执行过程中，我们可以看到系统一直在执行testA的这个函数，在这个函数里面我们执行了进程，通过restart 这个函数完成了从 ring0 到ring1 这个的转变。

### 中断重入
我们在中断的运行过程中，我们必须允许中断是可以重入的，所以我们必须引进新的机制来允许中断是可以重入的。可以允许中断是嵌套的。

程序在相应中断的过程中是会自动关闭中断，我们需要认为的打开中断，需要加入 sti 指令。

## 系统调用
系统调用是沟通操作系统和应用程序的桥梁。

## 8253/8254 PIT

时钟中断的的产生靠的是一个被称为 PIT的可编程间断时钟的芯片触发的。 这个芯片通常是Intel 8253, 8254. 8253有3个计数器，他们都是16位的，作为从0 到 1 分别为，每隔一段时间就产生一个时钟中断；每15 us 做一次 RAM刷新；连接 pc 喇叭。
时钟中断的默认发生频率就是18.2 hz. 如果想改变时钟中断的产生频率， 我们就需要改变改变计数器的值。
在这里我发现这个的操作和原来定义stm32的时候差不多。